# Bot Zeus - Discord Gaming Queue Management System

## Overview

Bot Zeus is a comprehensive Discord bot designed for managing competitive 1v1 gaming queues with an integrated payment system, automated mediation, and match tracking. The bot facilitates organized player-versus-player matches with built-in PIX payment processing, automatic mediator rotation, and comprehensive logging across multiple Discord channels. It includes a web server for health monitoring and keep-alive functionality to ensure 24/7 uptime on hosting platforms like Replit.

## Recent Changes (November 2025)

### Admin Room Creation System
- **Automatic room creation flow**: Admins can create rooms by simply sending messages:
  1. Send room ID (5-10 digits) → Bot reacts with ✅
  2. Send password (1-4 digits) → Room automatically created
  - Timeout: 5 minutes between ID and password
  - Auto-validation with emoji reactions (✅ success, ⏰ timeout, ❌ error)

### Enhanced Match Display
- **Doubled value display**: Match embeds now show "PAGAR" (doubled value)
- **Professional formatting**: Improved embed design with better visual hierarchy
- **Player mentions**: Clear player identification in match creation

### UI/UX Improvements
- **Menu reorganization**: Mediator menu now appears before PIX information
- **Simplified PIX copying**: Removed unnecessary quotes and formatting
- **Clean embeds**: Professional design across all commands (/rank, /manual)

### Technical Optimizations
- **Port 3000**: HTTP server now runs on port 3000 (compatible with Cron-Job.org)
- **Code cleanup**: Removed unused imports and dead code
- **Keep-alive**: 90-second interval (3x safety margin before timeout)

## User Preferences

Preferred communication style: Simple, everyday language.

## System Architecture

### Core Bot Framework
**Problem**: Need a reliable Discord bot that handles slash commands, events, and maintains persistent state.

**Solution**: Discord.py with command tree for slash commands, SQLite for data persistence, and asyncio-based task scheduling.

**Architecture decisions**:
- Uses Discord.py's `commands.Bot` with slash command support via `app_commands`
- Implements global error handling for slash commands to provide user-friendly error messages
- Cooldown and permission checks built into the command error handler
- Async/await patterns throughout for non-blocking operations

### Database Design
**Problem**: Need persistent storage for user data, match history, queue states, and payment records.

**Solution**: SQLite database with a schema that supports users, matches, queues, mediators, and transaction logs.

**Architecture decisions**:
- Single SQLite file (`bot/bot_zeus.db`) for simplicity and portability
- Likely includes tables for: users, matches, queues, mediators, transactions, logs
- Direct SQL queries using sqlite3 module (no ORM layer for reduced complexity)

**Trade-offs**:
- **Pro**: Simple deployment, no external database server needed
- **Con**: Limited to single-instance deployment, no concurrent write scaling

### Queue Management System
**Problem**: Organize players into competitive matches with fair value distribution and automated mediation.

**Solution**: Multi-tier queue system with predefined bet values and automated mediator assignment.

**Key features**:
- 1v1 queue system with 12 different bet tiers (ranging from $0.40 to $100.00)
- 10% fee per player (`TAXA_POR_JOGADOR = 0.10`)
- Coin rewards system (1 coin per victory)
- Separate queue types: MOB and Emulator
- Automated mediator rotation every 30 seconds

### Payment Integration
**Problem**: Handle real-money transactions for competitive matches safely and transparently.

**Solution**: PIX QR code generation for Brazilian payment system integration.

**Architecture decisions**:
- QR code generation using `qrcode` library
- Payment verification likely manual or webhook-based
- Transaction logging for audit trail
- In-memory QR code generation (`BytesIO`) to avoid filesystem operations

**Considerations**:
- PIX is Brazil-specific payment system
- Payment confirmation workflow likely involves admin verification or external webhook

### Logging & Auditing
**Problem**: Track all match-related activities for transparency and dispute resolution.

**Solution**: Multi-channel logging system with dedicated Discord channels for different event types.

**Log categories**:
- Matches created
- Matches confirmed
- Matches started
- Matches finished
- Matches refused/cancelled

**Benefits**:
- Complete audit trail
- Easy dispute resolution
- Transparency for community

### Web Server & Keep-Alive System
**Problem**: Discord bots hosted on platforms like Replit go to sleep after inactivity (~5 minutes), causing downtime.

**Solution**: Embedded aiohttp web server with optimized self-ping mechanism.

**Architecture decisions**:
- HTTP server on port 8080 using `aiohttp.web`
- Health check endpoint for external monitoring services
- Statistics endpoint for public metrics
- **Optimized keep-alive**: Self-ping every 90 seconds (3x before Replit timeout)
- Multiple async tasks for different monitoring intervals:
  - Ping task: 30s (latency monitoring)
  - Health check: 5min (database integrity)
  - Keep-alive auto-ping: 90s (uptime maintenance)
  - Mediator rotation: 30s
  - Auto role assignment: 60s

**Why 90 seconds?**:
- Previous 4-minute interval left only 1 minute margin before timeout
- 90-second interval provides 3 pings before 5-minute Replit timeout
- Maximizes reliability while minimizing unnecessary requests

### UI Components
**Problem**: Provide intuitive interaction patterns beyond text commands.

**Solution**: Discord UI components (Views, Buttons, Selects, Modals).

**Architecture decisions**:
- `discord.ui.View` for persistent interactive messages
- `Button` components for quick actions
- `Select` menus for multi-option choices
- `Modal` forms for text input collection
- All interactions use Discord's native component system

### Visualization & Analytics
**Problem**: Provide visual insights into match statistics and trends.

**Solution**: Matplotlib-based chart generation with headless rendering.

**Architecture decisions**:
- Uses `matplotlib` with `Agg` backend (non-GUI)
- Chart generation likely for leaderboards, win rates, payment history
- In-memory image generation to avoid filesystem clutter
- `defaultdict` for aggregating statistics

**Trade-offs**:
- **Pro**: Rich visualizations without external services
- **Con**: CPU-intensive for large datasets

### Permission & Role System
**Problem**: Control access to administrative and moderation features.

**Solution**: Discord role-based permissions with owner-level commands.

**Key elements**:
- Bot owner identified by username and ID
- Permission checks in command error handler
- Auto-role assignment task (60s interval)
- Likely has admin, mediator, and player role tiers

## External Dependencies

### Discord API
- **Library**: discord.py (with slash command support)
- **Purpose**: Bot framework, event handling, guild/member management
- **Key features used**: Intents (members, message_content), slash commands, UI components

### Database
- **Technology**: SQLite 3
- **Purpose**: Persistent storage for all bot data
- **File location**: `bot/bot_zeus.db`
- **Access pattern**: Direct SQL queries via sqlite3 module

### Payment System
- **Technology**: PIX (Brazilian instant payment system)
- **Implementation**: QR code generation via `qrcode` library
- **Integration**: Likely manual confirmation or external webhook verification

### Visualization
- **Library**: Matplotlib
- **Backend**: Agg (headless/non-interactive)
- **Purpose**: Generate statistics charts and graphs
- **Output**: PNG images sent as Discord attachments

### Web Server
- **Library**: aiohttp
- **Port**: 3000
- **Endpoints**:
  - `/ping` - Quick ping for Cron-Job.org
  - `/status` - Text-based status
  - `/health` - JSON health check
  - `/stats` - Database statistics
- **Purpose**: Keep-alive mechanism and external monitoring
- **Keep-alive interval**: 90 seconds (optimized for Replit)

### External Monitoring
- **Service**: Cron-Job.org (recommended)
- **Purpose**: External pings to web server for uptime assurance
- **Configuration**:
  - URL: `/ping` endpoint
  - Interval: Every 1-5 minutes
  - Expected response: "pong"

### Python Environment
- **Dependency management**: pyproject.toml (likely Poetry or similar)
- **Key libraries**:
  - discord.py
  - aiohttp
  - qrcode
  - matplotlib
  - sqlite3 (built-in)